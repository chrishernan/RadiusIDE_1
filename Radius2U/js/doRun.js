// Generated by CoffeeScript 1.10.0

/*
 doRun.coffee
 contains these methods:
 RadiusRun()			                // public
 RadiusStop()						// public
 */

(function() {
  var EV, NoReturnVal, NoVal, Radius, Token, callBuiltinFunction, callStack, doArrayAssignment, doAssignment, doAssignmentToObject, doClear, doPrint, errorDiv, functionTable, lookUp, myClone, noteError, noteError2, outputArea, rad, radiusEquals, runCommands, stopButton, stringify, symbolTablePop, symbolTablePush, symbolTableSet, trueToken, workingStack,
      hasProp = {}.hasOwnProperty;

  Radius = window.Radius;

  rad = Radius.Code;

  Token = Radius.Token;

  rad.currCommand = 0;

  rad.symbolTableStack = [];

  rad.STOP = false;

  rad.ERROR = false;

  rad.StepsPerTick = 500;

  rad.timeoutTime = 4;

  rad.stepsDone = 0;

  rad.timeouts = 0;

  rad.whileStack = [];

  outputArea = null;

  errorDiv = null;

  stopButton = null;

  NoVal = new Token(Token.NoVal);

  NoReturnVal = new Token(Token.NoVal, "No Return Val");

  trueToken = new Token(Token.Bool, true);

  trueToken = new Token(Token.Bool, false);

  workingStack = [];

  callStack = [];

  rad.userWindows = [];

  functionTable = {};

  rad.builtinFunctionNames = ['sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'integer', 'max', 'min', 'abs', 'floor', 'ceiling', 'pow', 'log', 'window', 'plot', 'xrange', 'yrange', 'fillrect', 'clearrect', 'drawrect', 'drawline', 'fillcolor', 'linecolor'];

  Radius.RadiusRun = function() {
    var p;
    rad.symbolTableStack = [{}];
    rad.STOP = false;
    rad.ERROR = false;
    rad.errors = [];
    rad.stepsDone = 0;
    rad.timeouts = 0;
    workingStack = [];
    callStack = [];
    functionTable = {};
    rad.commandPos = 0;
    p = 0;
    while (p < rad.commandList.length) {
      if (rad.commandList[p].type === Token.Command && rad.commandList[p].val === "#FUNCTION") {
        functionTable[rad.commandList[p + 1].val] = p;
      }
      if (rad.commandList[p].type === Token.Command && rad.commandList[p].val === "#ENDFUNCTION") {
        rad.commandPos = p;
      }
      p++;
    }
    if (rad.commandPos > 0) {
      rad.commandPos++;
    }
    rad.whileStack = [];
    return runCommands();
  };

  Radius.RadiusStop = function() {
    rad.STOP = true;
    return console.log("STOPPED");
  };

  runCommands = function() {
    var a, callingFnName, concat, curr, el, fnName, fnNumParms, fnnameTok, i, int_i, isLVal, j, k, keyname, keyval, l, len1, len2, lookedUp, newObject, next, nop, numArgs, numParmsPassed, objectElements, op1, op1str, op2, op2str, parameterName, parameterVal, ref, ref1, result, theIndex, theObject, themArgs, w;
    while (rad.commandPos < rad.commandList.length && rad.stepsDone < rad.StepsPerTick && !rad.STOP && !rad.ERROR) {
      curr = rad.commandList[rad.commandPos];
      if (curr.type === Token.Number || curr.type === Token.String) {
        workingStack.push(curr);
      } else if (curr.type === Token.LVal) {
        workingStack.push(curr);
      } else if (curr.type === Token.RVal) {
        lookedUp = lookUp(curr.val);
        workingStack.push(new Token(lookedUp.type, lookedUp.val, curr.id, curr.whichParm, curr.start, curr.length));
      } else if (curr.type === Token.Counter) {
        workingStack.push(curr);
      } else if (curr.type === Token.Label) {
        workingStack.push(curr);
      } else if (curr.type === Token.Function) {
        workingStack.push(curr);
      } else if (curr.type === Token.Operator) {
        switch (curr.val) {
          case "U-":
            op1 = workingStack.pop();
            if (op1.type === Token.Number) {
              workingStack.push({
                va: SchemeNumber.fn["-"](op1.val),
                ty: Token.Number,
                id: op1.id,
                st: curr.st,
                length: (op1.st + op1.length) - curr.st
              });
            } else {
              noteError2(op1, "Argument to - (unary minus) is not a number: " + EV(op1) + ". (R12)");
            }
            break;
          case "+":
          case "-":
          case "*":
          case "/":
            op2 = workingStack.pop();
            op1 = workingStack.pop();
            if (op1.type === Token.Number && op2.type === Token.Number) {
              result = SchemeNumber.fn[curr.val].call(this, op1.val, op2.val);
              workingStack.push(new Token(Token.Number, result, op1.id, op1.whichParm, op1.st, op2.st + op2.length - op1.st));
            } else {
              if (op1.type === Token.Number) {
                noteError2(op2, "Argument to " + curr.val + " is not a number: " + EV(op2) + " (R13)");
              } else {
                noteError2(op1, "Argument to " + curr.val + " is not a number: " + EV(op1) + " (R14)");
              }
            }
            break;
          case "&":
          case "&&":
            op2 = workingStack.pop();
            op1 = workingStack.pop();
            if (op1.type === Token.Array && (op1.isCommand != null) && op2.type === Token.Array && (op2.isCommand != null)) {
              ref = op2.val;
              for (j = 0, len1 = ref.length; j < len1; j++) {
                a = ref[j];
                op1.val.push(a);
              }
              workingStack.push(op1);
            } else {
              op2str = stringify(op2);
              op1str = stringify(op1);
              if (curr.val === "&") {
                concat = op1str + op2str;
              } else if (curr.val === "&&") {
                concat = op1str + " " + op2str;
              }
              workingStack.push(new Token(Token.String, concat, op1.id, op1.whichParm, op1.st, (op2.st + op2.length) - op1.st));
            }
            break;
          case "=":
          case "<":
          case ">":
          case "<=":
          case ">=":
          case "!=":
            op2 = workingStack.pop();
            op1 = workingStack.pop();
            if (op1.type === Token.Number && op2.type === Token.Number) {
              if (curr.val === "!=") {
                result = !SchemeNumber.fn["="].call(this, op1.val, op2.val);
              } else {
                result = SchemeNumber.fn[curr.val].call(this, op1.val, op2.val);
              }
              workingStack.push(new Token(Token.Bool, result, op1.id, op1.whichParm, op1.st, op2.st + op2.length - op1.st));
            } else {
              if (op1.type === Token.Number) {
                noteError2(op2, "Argument to <u>" + curr.val + "</u> is not a number: " + EV(op2) + " (R15)");
              } else {
                noteError2(op1, "Argument to <u>" + curr.val + "</u> is not a number: " + EV(op1) + " (R16)");
              }
            }
            break;
          case "and":
          case "or":
            op2 = workingStack.pop();
            op1 = workingStack.pop();
            if (op1.type === Token.Bool && op2.type === Token.Bool) {
              if (curr.val === "and") {
                result = op1.val && op2.val;
              } else {
                result = op1.val || op2.val;
              }
              workingStack.push(new Token(Token.Bool, result, op1.id, op1.whichParm, op1.st, op2.st + op2.length - op1.st));
            } else {
              if (op1.type === Token.Bool) {
                noteError2(op2, "Argument to <u>" + curr.val + "</u> is not a Boolean: " + EV(op2) + " (R17)");
              } else {
                noteError2(op1, "Argument to <u>" + curr.val + "</u> is not a Boolean: " + EV(op1) + " (R18)");
              }
            }
            break;
          case "not":
            op1 = workingStack.pop();
            if (op1.type === Token.Bool) {
              workingStack.push(new Token(Token.Bool, !op1.bal, op1.id, op1.whichParm, curr.st, op1.st + op1.length - curr.st));
            } else {
              noteError2(op1, "Argument to <u>" + curr.val + "</u> is not a Boolean: " + EV(op1) + " (R19)");
            }
            break;
          case "fncall":
            fnnameTok = workingStack.pop();
            if ($.inArray(fnnameTok.val, rad.builtinFunctionNames) > -1) {
              numArgs = workingStack.pop().val;
              themArgs = [];
              for (i = k = 0, ref1 = numArgs; k < ref1; i = k += 1) {
                themArgs.unshift(workingStack.pop());
              }
              workingStack.push(callBuiltinFunction(fnnameTok, themArgs));
            } else {
              callStack.push(rad.commandPos);
              workingStack.push(fnnameTok);
              rad.commandPos = functionTable[fnnameTok.val] - 1;
            }
            break;
          case "attr":
            keyname = workingStack.pop();
            keyval = workingStack.pop();
            if (keyname.type !== Label) {
              noteError2(keyname, "keyname " + EV(keyname) + " is not a String. (R25!)");
            }
            if (keyval.type === Token.RVal) {
              keyval = lookUp(keyval.val);
            }
            workingStack.push({
              $attr: keyname.val,
              $val: keyval
            });
            break;
          case "[]":
            op1 = workingStack.pop();
            if (op1.type === Token.Counter) {
              numArgs = op1.val;
            } else {
              noteError2(op1, "Argument to [] is not a COUNTER. (R26!)");
            }
            newObject = {
              va: {},
              ty: OBJECT,
              id: curr.id,
              st: curr.st,
              length: curr.length
            };
            objectElements = workingStack.splice(-numArgs, numArgs);
            for (l = 0, len2 = objectElements.length; l < len2; l++) {
              el = objectElements[l];
              if (typeof el === "object" && (el.$attr != null)) {
                newObject.val[el.$attr] = el.$val;
              } else {
                if (newObject.type === Token.Object) {
                  newObject.val = [el];
                  newObject.type = Token.Array;
                } else {
                  newObject.val.push(el);
                }
              }
            }
            workingStack.push(newObject);
            break;
          case "index":
            next = rad.commandList[rad.commandPos + 1];
            if ((next != null) && next.type === Token.Command && next.val === "#ASSIGN") {
              isLVal = true;
            } else {
              isLVal = false;
            }
            theIndex = workingStack.pop();
            theObject = workingStack.pop();
            if (theObject.type === Token.NoVal) {
              noteError2(theObject, "Cannot use index operation on <code>NoVal</code>. (R30A)");
              break;
            }
            if (theIndex.type === Token.NoVal) {
              noteError2(theIndex, "Index is <code>NoVal</code>. (R30B)");
              break;
            }
            if (theObject.type === Token.LVal) {
              theObject = lookUp(theObject.val);
            }
            result = NoVal;
            if (theObject.type !== Token.Object && theObject.type !== Token.Array) {
              noteError2(theObject, "Expected object or array, found " + EV(theObject) + ". (R30)");
            }
            if (theObject.type === Token.Object && !(theIndex.type === Token.String || theIndex.type === Token.Label)) {
              noteError2(theIndex, "Can't use " + EV(theIndex) + " as an object index. (R30E)");
            }
            if (theObject.type === Token.Array && theIndex.type !== Token.Number) {
              noteError2(theIndex, "Can't use " + EV(theIndex) + " as an array index. (R30F)");
            }
            if (theIndex.type === Token.Number) {
              i = theIndex.val;
              if (SchemeNumber.fn["<"](i, Radius.SN1)) {
                noteError2(theIndex, "Array index must be 1 or greater, found " + EV(theIndex) + " (R31)");
              }
              if (SchemeNumber.fn[">"](i, Radius.SN10000)) {
                noteError2(theIndex, "Array index must be 10,000 or less, found " + EV(theIndex) + " (R32)");
              }
              if (!SchemeNumber.fn["integer?"](i)) {
                noteError2(theIndex, "Array index must be an integer, found " + EV(theIndex) + " (R33)");
              }
            }
            if (isLVal) {
              workingStack.push([theObject, theIndex.val]);
            } else {
              if (theIndex.type === Token.Number) {
                int_i = parseInt(i.toString(), 10);
                if (int_i <= theObject.val.length) {
                  result = theObject.val[int_i - 1];
                }
              } else {
                if (theObject.val[theIndex.val] != null) {
                  result = theObject.val[theIndex.val];
                } else {
                  result = NoVal;
                }
              }
              workingStack.push({
                va: result.val,
                ty: result.type,
                id: theObject.id,
                st: theObject.st,
                length: theIndex.st + theIndex.length + 1 - theObject.st
              });
            }
            break;
          default:
            console.log("***unhandled operator:", curr.val);
        }
      } else if (curr.type === Token.Command) {
        switch (curr.val) {
          case "#ASSIGN":
            op1 = workingStack.pop();
            op2 = workingStack.pop();
            if ($.isArray(op1)) {
              doAssignmentToObject(op1[0], op1[1], op2);
            } else if (op1.type === Token.Object) {
              doAssignment(op1, op2);
            } else {
              doAssignment(op1.val, op2);
            }
            break;
          case "#SHOW":
            w = 0;
            if (curr.windowIndex != null) {
              w = curr.windowIndex;
            }
            doPrint(w, workingStack.pop());
            break;
          case "#CLEAR":
            doClear();
            break;
          case "noprint":
            workingStack.pop();
            break;
          case "#IF":
            op1 = workingStack.pop();
            if (op1.type === Token.Bool) {
              if (op1.val) {

              } else {
                while (!((rad.commandList[rad.commandPos].val === "#ELSE" || rad.commandList[rad.commandPos].val === "#ENDIF") && rad.commandList[rad.commandPos].depth === curr.depth)) {
                  rad.commandPos++;
                }
              }
            } else {
              noteError2(op1, "Argument to " + curr.val + " not a Boolean, found &laquo;" + stringify(op1) + "&raquo;. (R41)");
            }
            break;
          case "#ELSE":
            while (!(rad.commandList[rad.commandPos].val === "#ENDIF" && rad.commandList[rad.commandPos].depth === curr.depth)) {
              rad.commandPos++;
            }
            break;
          case "#ENDIF":
            nop = true;
            break;
          case "#WHILE":
            op1 = workingStack.pop();
            if (op1.type === Token.Bool) {
              if (op1.val) {

              } else {
                while (!(rad.commandList[rad.commandPos].val === "#ENDWHILE" && rad.commandList[rad.commandPos].depth === curr.depth)) {
                  rad.commandPos++;
                }
              }
            } else {
              noteError2(op1, "Argument to <code>while</code> not a Boolean, found " + EV(op1) + ". (R42)");
            }
            break;
          case "#ENDWHILE":
            rad.commandPos = rad.commandPos - curr.getBack - 1;
            break;
          case "#BREAK":
            while (!(rad.commandList[rad.commandPos].val === "#ENDWHILE" && rad.commandList[rad.commandPos].depth === curr.depth)) {
              rad.commandPos++;
            }
            break;
          case "#FUNCTION":
            callingFnName = workingStack.pop();
            numParmsPassed = workingStack.pop().val;
            fnName = rad.commandList[rad.commandPos + 1].val;
            fnNumParms = rad.commandList[rad.commandPos + 2].val;
            if (fnNumParms !== numParmsPassed) {
              noteError2(callingFnName, "Function " + fnName + " expected " + fnNumParms + " parameter" + (fnNumParms === 1 ? "" : "s") + ", but " + numParmsPassed + (numParmsPassed === 1 ? " was" : " were") + " found.  (R43)");
              return;
            }
            symbolTablePush();
            i = 0;
            while (i < fnNumParms) {
              parameterVal = workingStack.pop();
              parameterName = rad.commandList[rad.commandPos + 2 + fnNumParms - i].val;
              doAssignment(parameterName, parameterVal);
              i++;
            }
            rad.commandPos += 2 + fnNumParms;
            break;
          case "#ENDFUNCTION":
          case '#RETURN':
          case '#RETURNNOVALUE':
            symbolTablePop();
            if (curr.val === '#RETURNNOVALUE' || curr.val === '#ENDFUNCTION') {
              workingStack.push(NoVal);
            }
            rad.commandPos = callStack.pop();
            break;
          default:
            console.log("****unexpected op: ", curr);
        }
      } else {
        console.log("****don't know what to do with", curr);
      }
      rad.commandPos++;
      rad.stepsDone++;
    }
    if (rad.STOP || rad.ERROR) {
      return;
    }
    if (rad.commandList.length === rad.commandPos) {
      if (workingStack.length > 0) {
        console.log("**Something left on workingStack**", workingStack);
      } else {
        console.log("Successful end of program. rad.stepsDone:", rad.stepsDone, rad.timeouts);
      }
      return;
    }
    console.log("timing out ", rad.stepsDone, rad.timeouts);
    if (rad.timeouts > 100) {
      console.log("BAILING", rad.timeouts);
      return;
    }
    rad.stepsDone = 0;
    rad.timeouts++;
    setTimeout(runCommands, rad.timeoutTime);
  };

  doClear = function() {
    return $('#OutputPane').empty();
  };

  doPrint = function(windowIndex, arg) {
    var div, str1, str2;
    if (arg.type === Token.Eject) {
      return;
    }
    if (arg.type === Token.Array && (arg.isCommand != null)) {
      rad.doPrintCanvas(windowIndex, arg);
      return;
    }
    str1 = stringify(arg);
    str2 = str1.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\ /g, "&nbsp;").replace(/��/g, "<");
    if (windowIndex === 0) {
      $("#OutputPane").append(str2 + "<br>");
      div = document.getElementById('OutputPane');
      return div.scrollTop = div.scrollHeight - div.clientHeight;
    } else {
      if (rad.windowIsOpen(windowIndex)) {
        return $("#" + rad.userWindows[windowIndex]).append(str2 + "<br>");
      } else {
        return console.log('no open user Window', windowIndex);
      }
    }
  };

  doAssignment = function(name, value) {
    if (value.type === Token.Object) {
      return symbolTableSet(name, jQuery.extend(true, {}, value));
    } else if (value.type === Token.RVal) {
      return doAssignment(name, lookUp(value.val));
    } else {
      return symbolTableSet(name, value);
    }
  };

  doAssignmentToObject = function(object, index, value) {
    var indexN, newValue;
    indexN = -1;
    if (typeof index !== "string") {
      indexN = +(index.toString());
    }
    if (value.type === Token.Object) {
      console.log("doAssignmentToObject - OBJECT", value);
      if (indexN === -1) {
        return object.val[index] = jQuery.extend(true, {}, value);
      } else {
        return object.val["#array"][indexN - 1] = jQuery.extend(true, {}, value);
      }
    } else if (value.type === RVAL) {
      console.log("doAssignmentToObject - RVAL", value);
      newValue = lookUp(value.val);
      if (newValue === NoVal) {
        if (indexN === -1) {
          return object.val[index] = NoVal;
        } else {
          return object.val["#array"][indexN - 1] = NoVal;
        }
      } else {
        return doAssignmentToObject(object, index, newValue.val);
      }
    } else {
      console.log("doAssignmentToObject - other", value);
      if (indexN === -1) {
        return object.val[index] = value;
      } else {
        return object.val[indexN - 1] = value;
      }
    }
  };

  symbolTableSet = function(name, value) {
    var currentSymbolTable;
    currentSymbolTable = rad.symbolTableStack[rad.symbolTableStack.length - 1];
    return currentSymbolTable[name.toLowerCase()] = [value, name];
  };

  lookUp = function(name) {
    var currSymbolTable, nameLC;
    nameLC = name.toLowerCase();
    if (nameLC === "true") {
      return trueToken;
    }
    if (nameLC === "false") {
      return falseToken;
    }
    currSymbolTable = rad.symbolTableStack[rad.symbolTableStack.length - 1];
    if (currSymbolTable[nameLC] != null) {
      return currSymbolTable[nameLC][0];
    } else {
      return NoVal;
    }
  };

  symbolTablePush = function() {
    return rad.symbolTableStack.push({});
  };

  symbolTablePop = function() {
    return rad.symbolTableStack.pop();
  };

  doArrayAssignment = function(args, evaledArg) {
    var index, indexN, symTab, variable;
    symTab = rad.symbolTableStack[rad.symbolTableStack.length - 1];
    variable = symTab[args[0].val];
    if (!((variable != null) && variable.type === Token.Object)) {
      noteError(args[0].li, args[0].st, args[0].st + args[0].val.length, "Variable " + args[1].val + " is indexed with [] but is not an object. (R50)");
      return;
    }
    index = RadiusEval(args[1]);
    if (index.type === Token.Number) {
      if (Radius.SN0.gt(index.val) || Radius.SN0.eq(index.val)) {
        noteError(args[1].li, args[1].st, args[1].st + 2, "Index of " + args[0].val + " must be a positive integer, not " + index.val.toString() + ". (R51)");
      } else if (index.val.gt(Radius.SN10000)) {
        noteError(args[1].li, args[1].st, args[1].st + 2, "Index of " + args[0].val + " must be no greater than 10000, not " + index.val.toString() + ". (R52)");
      } else if (index.val.toString().indexOf(".") !== -1) {
        noteError2(args[1], "Index of " + args[0].val + " must be a whole number, not " + index.val.toString() + ". (R53)");
      } else {
        indexN = +(index.val.toString());
        variable.val[indexN - 1] = RadiusEval(args[2]);
      }
    } else if (index.type === Token.String) {
      variable.val[index.val] = RadiusEval(args[2]);
    } else {
      noteError2(args[1], "Index of " + args[0].val + " is not a number or a string. (R54)");
    }
  };

  callBuiltinFunction = function(fnnameTok, themArgs) {
    var argList, fnname, i, j, len1, schemeName, theArg, token, windowCommand, windowIndex;
    fnname = fnnameTok.val.toLowerCase();
    switch (fnname) {
      case 'sin':
      case 'cos':
      case 'tan':
      case 'asin':
      case 'acos':
      case 'atan':
      case 'abs':
      case 'floor':
      case 'ceiling':
        if (themArgs.length === 0) {
          noteError2(fnnameTok, "Argument missing in call to " + fnname + ". (R60)");
        }
        if (themArgs.length > 1) {
          noteError2(fnnameTok, "Too many arguments in call to " + fnname + ". (R61)");
        }
        theArg = themArgs[0];
        if (theArg.type !== Token.Number) {
          noteError2(fnnameTok, "Argument must be a number in call to " + fnname + ", found:" + EV(theArg) + ". (R62)");
        }
        if (!rad.ERROR) {
          return {
            ty: Token.Number,
            va: SchemeNumber.fn[fnname](theArg.val)
          };
        }
        break;
      case 'integer':
        if (themArgs.length === 0) {
          noteError2(fnnameTok, "Argument missing in call to " + fnname + ". (R63)");
        }
        if (themArgs.length > 1) {
          noteError2(fnnameTok, "Too many arguments in call to " + fnname + ". (R64)");
        }
        theArg = themArgs[0];
        if (theArg.type !== Token.Number) {
          noteError2(fnnameTok, "Argument must be a number in call to " + fnname + ", found &laquo;" + stringify(theArg) + "&raquo;. (R65)");
        }
        if (!rad.ERROR) {
          return {
            ty: Token.Bool,
            va: SchemeNumber.fn[fnname + "?"](theArg.val)
          };
        }
        break;
      case 'pow':
      case 'log':
        if (themArgs.length < 2) {
          noteError2(fnnameTok, "Argument missing in call to " + fnname + ". (R66)");
        }
        if (themArgs.length > 2) {
          noteError2(fnnameTok, "Too many arguments in call to " + fnname + ". (R67)");
        }
        if (rad.ERROR) {
          return 0;
        }
        if (themArgs[0].type !== Token.Number) {
          noteError2(fnnameTok, "First argument must be a number in call to " + fnname + ", found &laquo;" + stringify(themArgs[0]) + "&raquo;. (R68)");
        }
        if (themArgs[1].type !== Token.Number) {
          noteError2(fnnameTok, "Second argument must be a number in call to " + fnname + ", found &laquo;" + stringify(themArgs[1]) + "&raquo;. (R69)");
        }
        if (fnname === 'pow') {
          schemeName = 'expt';
        } else {
          schemeName = 'log';
        }
        if (!rad.ERROR) {
          return {
            ty: Token.Number,
            va: SchemeNumber.fn[schemeName](themArgs[0].val, themArgs[1].val)
          };
        }
        break;
      case 'max':
      case 'min':
        if (themArgs.length < 1) {
          noteError2(fnnameTok, "Argument missing in call to " + fnname + ". (R80)");
        }
        argList = [];
        for (j = 0, len1 = themArgs.length; j < len1; j++) {
          token = themArgs[j];
          if (token.type !== Token.Number) {
            noteError2(token, "Argument must be a number in call to " + fnname + ", found:" + EV(token) + ". (R81)");
          }
          argList.push(token.val);
        }
        if (!rad.ERROR) {
          return {
            ty: Token.Number,
            va: SchemeNumber.fn[fnname].apply(this, argList)
          };
        }
        break;
      case 'window':
        if (themArgs.length < 2) {
          noteError2(fnnameTok, "Missing arguments in call to " + fnname + ". (R82)");
        }
        if (themArgs.length > 3) {
          noteError2(fnnameTok, "Too many arguments in call to " + fnname + ". (R83)");
        }
        if (themArgs[0].val.toLowerCase() === "create" && themArgs.length !== 3) {
          noteError2(fnnameTok, "When using Create option, must have three parameters. (R85)");
        }
        windowIndex = -1;
        if (themArgs[1].type === Token.Number) {
          i = themArgs[1].val;
          if (SchemeNumber.fn["<"](i, Radius.SN1)) {
            noteError2(fnnameTok, "Window index must be 1 or greater, found " + stringify(theIndex) + ". (R90)");
          }
          if (SchemeNumber.fn[">"](i, Radius.SN10000)) {
            noteError2(fnnameTok, "Window index must be 10,000 or less, found " + stringify(theIndex) + ". (R91)");
          }
          if (!SchemeNumber.fn["integer?"](i)) {
            noteError2(fnnameTok, "Window index must be an integer, found " + stringify(theIndex + ". (R92)"));
          }
          windowIndex = parseInt(i.toString(), 10);
        } else {
          noteError2(fnnameTok, "The second parameter must be a whole number. (R93) ");
        }
        if (windowIndex === -1) {
          return NoReturnVal;
        }
        if (themArgs[0].type !== Token.String) {
          noteError2(fnnameTok, "First arg to window() isn't a string: " + themArgs[0] + ". (R94)");
          return NoReturnVal;
        }
        windowCommand = themArgs[0].val;
        switch (windowCommand.toLowerCase()) {
          case "create":
            rad.windowCreate(windowIndex, themArgs[2]);
            break;
          default:
            noteError2(fnnameTok, "Unknown first argument to window():" + windowCommand + ". (R95)");
        }
        return NoReturnVal;
      case 'fillrect':
      case 'clearrect':
      case 'drawrect':
        if (themArgs.length !== 4) {
          return noteError2(fnnameTok, "Exactly four arguments are needed for " + fnname + ". (R102)");
        } else {
          return {
            ty: Token.Array,
            isCommand: true,
            va: [
              {
                ty: OBJECT,
                va: {
                  $cmd: true,
                  cmd: fnname,
                  left: themArgs[0],
                  top: themArgs[1],
                  width: themArgs[2],
                  height: themArgs[3]
                }
              }
            ]
          };
        }
        break;
      case 'drawline':
        if (themArgs.length !== 4) {
          return noteError2(fnnameTok, "Exactly four arguments are needed for " + fnname + ". (R103)");
        } else {
          return {
            ty: Token.Array,
            isCommand: true,
            va: [
              {
                ty: OBJECT,
                va: {
                  $cmd: true,
                  cmd: fnname,
                  x1: themArgs[0],
                  y1: themArgs[1],
                  x2: themArgs[2],
                  y2: themArgs[3]
                }
              }
            ]
          };
        }
        break;
      case 'fillcolor':
      case 'linecolor':
        if (themArgs.length === 1 && themArgs[0].type === Token.String) {
          return {
            ty: Token.Array,
            isCommand: true,
            va: [
              {
                ty: OBJECT,
                va: {
                  cmd: fnname,
                  colorname: themArgs[0]
                }
              }
            ]
          };
        } else if (themArgs.length === 3 && themArgs[0].type === Token.Number && themArgs[1].type === Token.Number && themArgs[2].type === Token.Number) {
          return {
            ty: Token.Array,
            isCommand: true,
            va: [
              {
                ty: OBJECT,
                va: {
                  cmd: fnname,
                  red: themArgs[0],
                  green: themArgs[1],
                  blue: themArgs[2]
                }
              }
            ]
          };
        } else {
          return noteError2(fnnameTok, fnname + " parameters must be a color name or rgb. (R104)");
        }
        break;
      case 'plot':
        if (themArgs.length === 2 && themArgs[0].type === Token.Number && themArgs[1].type === Token.Number) {
          return {
            ty: Token.Array,
            isCommand: true,
            va: [
              {
                ty: OBJECT,
                va: {
                  cmd: fnname,
                  x: themArgs[0],
                  y: themArgs[1]
                }
              }
            ]
          };
        } else {
          return noteError2(fnnameTok, fnname + " parameters must x, y. (R105)");
        }
        break;
      default:
        console.log("didn't recognize function ", fnname);
        return NoReturnVal;
    }
  };


  /*
   windowCreate = (windowIndex, parmObj) ->
   console.log('windowCreate1', windowIndex, parmObj)
   if windowIsOpen(windowIndex)
   console.log("ignore windowCreate because window " + windowIndex + " already exists.")
   return
   if userWindows[windowIndex]?     # was the window created but now is gone?
   $("#RadiusChild"+windowIndex).dialog('destroy').remove()
   parms = {}
   parms = parmObj.val if parmObj?
   * window parameters have default values; invalid values in parmObj are ignored
   title = "Untitled"
   width = 300
   height = 200
   title = parms.title.val if parms.title? and parms.title.type == STRING
   if parms.width? and parms.width.type == NUMBER
   i = parms.width.val  # i is a SchemeNumber
   if SchemeNumber.fn[">"](i, SchemeNumber1) and
   SchemeNumber.fn["<"](i, SchemeNumber2000)
   width = parseInt(i.toString(), 10)
   if parms.height? and parms.height.type == NUMBER
   i = parms.height.val  # i is a SchemeNumber
   if SchemeNumber.fn[">"](i, SchemeNumber1) and
   SchemeNumber.fn["<"](i, SchemeNumber2000)
   height = parseInt(i.toString(), 10)  # BUG - doesn't work for non-ints
   #console.log('windowCreate2', title, width, height)
   divID = "RadiusChild" + windowIndex
   $("body").append("<div id='#{divID}'></div>")
   $("#"+divID).dialog({title: title, width: width, height: height})
   userWindows[windowIndex] = divID
   #$("#"+divID).append("this is line <b>one</b><br>")
   #$("#"+divID).append("<i>this is line<.i>two<br>")
   * - open new window
   #userWindows[windowIndex] = window.open('UIchild.html', # URL to load
   *		'RadiusWindow' + windowIndex,
   *		"width=#{width},height=#{height},menubar=false,toolbar=false,location=false" +
   *				"status=false,scrollbars=true,resizable=true")
   *
   * test
   * w = userWindows[windowIndex]
   * w.document.body.innerHTML = "THIS <b>IS</b> IT!"
   return

   windowIsOpen = (windowIndex) ->
   return false if not userWindows[windowIndex]?
   open = $("#"+userWindows[windowIndex]).dialog("isOpen")
   return (typeof open == "boolean") and open
   */

  noteError = function(id, startPos, length, message) {
    rad.ERROR = true;
    if (typeof startPos === "number" && typeof length === "number") {
      return rad.errors.push([id, startPos, length, message]);
    } else {
      return console.log("invalid call to noteError:", id, startPos, length, message);
    }
  };

  noteError2 = function(token, message) {
    var len, str2;
    if ((token != null) && (token.length != null)) {
      len = token.length;
    } else {
      console.log('in noteError2, no .length in', token);
      len = typeof token.val === "string" ? token.val.length : 3;
    }
    str2 = message;
    return noteError(token.id, token.st, len, str2);
  };

  EV = function(v) {
    return "{" + stringify(v) + "}";
  };

  stringify = function(X) {
    var decimalPoint, fix, i, key, keys, p, ref, s, value;
    if ((X == null) || X === NoVal || X.type === Token.NoVal) {
      return "<code>NoVal</code>";
    }
    if (X.type === Token.RVal) {
      X = lookUp(X.val);
    }
    if (X === NoVal) {
      return "��i>NoVal��/i>";
    }
    if (X.type === Token.String) {
      return X.val;
    }
    if (X.type === Token.Number) {
      fix = X.val.toFixed(10);
      decimalPoint = fix.indexOf(".");
      p = fix.length - 1;
      while (p >= decimalPoint) {
        if (fix[p] === ".") {
          return fix.substr(0, p);
        }
        if (fix[p] !== "0") {
          return fix.substr(0, p + 1);
        }
        p--;
      }
    }
    if (X.type === Token.Bool && X.val) {
      return "true";
    }
    if (X.type === Token.Bool) {
      return "false";
    }
    if (X.type === Token.Array) {
      s = "[";
      i = 0;
      while (i < X.val.length) {
        s += stringify(X.val[i]);
        i++;
        if (i < X.val.length) {
          s += ", ";
        }
      }
      return s + "]";
    }
    if (X.type >= Token.Object) {
      s = "[";
      keys = [];
      ref = X.val;
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        keys.push(key);
      }
      if (keys.length > 0) {
        keys.sort();
        i = 0;
        while (i < keys.length) {
          s += keys[i] + ": " + stringify(X.val[keys[i]]);
          i++;
          if (i < keys.length) {
            s += ", ";
          }
        }
      }
      s += "]";
      return s;
    }
    console.log("ruh roh", X);
    return "ruh roh " + X;
  };

  radiusEquals = function(left, right) {
    var i, j, k, key, leftProps, ref, ref1, ref2, ref3, rightProps, value;
    if (left.type !== right.type) {
      return false;
    }
    if (left.val === NoVal || right.val === NoVal) {
      return false;
    }
    if (left.type === Token.Bool) {
      return left.val === right.val;
    }
    if (left.type === Token.String) {
      return left.val === right.val;
    }
    if (left.type === Token.Number) {
      return SchemeNumber.fn["="].call(this, left.val, right.val);
    }
    if (left.type === Token.Array) {
      if (left.val.length !== right.val.length) {
        return false;
      }
      for (i = j = 0, ref = left.val.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (!objectEquals(left.val[i], right.val[i])) {
          return false;
        }
      }
      return true;
    }
    ref1 = left.val;
    for (key in ref1) {
      if (!hasProp.call(ref1, key)) continue;
      value = ref1[key];
      leftProps = key;
    }
    ref2 = right.val;
    for (key in ref2) {
      if (!hasProp.call(ref2, key)) continue;
      value = ref2[key];
      rightProps = key;
    }
    if (leftProps.length !== rightProps.length) {
      return false;
    }
    for (i = k = 0, ref3 = leftProps.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
      if (leftProps[i] !== rightProps[i]) {
        return false;
      }
      if (!objectEquals(left.val[leftProps[i]], right.val[rightProps[i]])) {
        return false;
      }
    }
    return true;
  };

  myClone = function(o) {
    if (typeof o !== 'object') {
      return o;
    }
    if ($.isArray(o)) {
      return $.extend(true, [], o);
    } else {
      return $.extend(true, {}, o);
    }
  };

}).call(this);
