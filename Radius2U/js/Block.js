// Generated by CoffeeScript 1.10.0
(function() {
  var Block, Radius, TheBlockList, barStack, blockIndent, closeEnoughToAttach;

  Radius = window.Radius;

  TheBlockList = Radius.TheBlockList;

  Block = Radius.Block;

  blockIndent = 15;

  closeEnoughToAttach = 10;

  barStack = [];

  Radius.BlockList = (function() {
    function BlockList() {
      this.blocks = [];
      this.prototypes = [];
    }

    BlockList.prototype.addBlock = function(block1) {
      return this.blocks.push(block1);
    };

    BlockList.prototype.addPrototypeBlock = function(block1) {
      return this.prototypes.push(block1);
    };

    BlockList.prototype.removePrototypeBlock = function(block1) {
      var n;
      n = this.prototypes.indexOf(block1);
      if (n > -1) {
        return this.prototypes.splice(n, 1);
      }
    };

    BlockList.prototype.deleteBlock = function(block) {
      var n;
      n = this.blocks.indexOf(block);
      if (n === -1) {
        return console.log("**ERROR** in BlockList.deleteBlock, could not find", block, "in", this);
      } else {
        return this.blocks.splice(n, 1);
      }
    };

    BlockList.prototype.getStartBlock = function() {
      var bl, j, len, ref;
      ref = this.blocks;
      for (j = 0, len = ref.length; j < len; j++) {
        bl = ref[j];
        if (bl.list[0].name === 'Start') {
          return bl;
        }
      }
      console.log('**getStartBlock returns null');
      return null;
    };

    BlockList.prototype.getFunctionBlocks = function() {
      var bl, fb, j, len, ref;
      fb = [];
      ref = this.blocks;
      for (j = 0, len = ref.length; j < len; j++) {
        bl = ref[j];
        if (bl.list[0].name === 'function') {
          fb.push(bl);
        }
      }
      return fb;
    };

    BlockList.prototype.display = function() {
      var bl, j, len, ref;
      console.log('--------', this.blocks.length, 'blocks --------');
      ref = this.blocks;
      for (j = 0, len = ref.length; j < len; j++) {
        bl = ref[j];
        bl.blockDisplay();
      }
    };

    BlockList.prototype.findBoxByID = function(boxID) {
      var bl, found, j, len, ref;
      ref = this.blocks;
      for (j = 0, len = ref.length; j < len; j++) {
        bl = ref[j];
        found = bl.findBoxByID(boxID);
        if (found != null) {
          return found;
        }
      }
      return null;
    };

    BlockList.prototype.findPrototypeBoxByID = function(boxID) {
      var bl, j, len, ref;
      ref = this.prototypes;
      for (j = 0, len = ref.length; j < len; j++) {
        bl = ref[j];
        if (bl.id === boxID) {
          return bl;
        }
      }
      console.log('***in findPrototypeBoxById cannot find boxID', boxID, '@prototypes:', this.prototypes);
      return null;
    };

    BlockList.prototype.removeAllBlocks = function() {
      return this.blocks = [];
    };

    BlockList.prototype.getAllBlocks = function() {
      return this.blocks;
    };

    return BlockList;

  })();


  /*
  	loadFromStorage: (o) ->
  		$('#ProgrammingPane').empty()   # zap all Box DOM objects
   */

  Radius.Block = (function() {
    Block.nextSeq = 1000;

    function Block(box) {
      var b, j, len, ref;
      this.list = [];
      if (box != null) {
        if (Array.isArray(box)) {
          this.list = box;
          ref = this.list;
          for (j = 0, len = ref.length; j < len; j++) {
            b = ref[j];
            b.parentBlock = this;
          }
        } else {
          this.list.push(box);
          box.parentBlock = this;
        }
      }
      this.isABox = false;
      this.parentBlock = null;
      this.seq = Block.nextSeq++;
    }

    Block.prototype.moveTo = function(newX, newY) {
      return this.lineUpBlock(newX, newY);
    };

    Block.prototype.lineUpBlock = function(xStart, yStart) {
      var b, blockBottom, j, len, ref, theBar, xPos, yPos;
      if (this.list.length === 0) {
        return yStart + 20;
      }
      if ((xStart != null) && (yStart != null)) {
        xPos = xStart;
        yPos = yStart;
      } else {
        if (this.parentBlock != null) {
          return this.parentBlock.lineUpBlock();
        }
        barStack = [];
        xPos = this.list[0].x;
        yPos = this.list[0].y;
      }
      ref = this.list;
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          b.setPos(xPos, yPos);
          if (b.name === 'bar') {
            barStack.push(b);
          } else {
            yPos = b.getBottom() - 1;
          }
        } else {
          blockBottom = b.lineUpBlock(xPos + blockIndent, yPos);
          yPos = blockBottom;
          if (barStack.length > 0) {
            theBar = barStack.pop();
            $('#' + theBar.id).height(yPos - theBar.y);
          }
        }
      }
      return yPos;
    };

    Block.prototype.split = function(box) {
      var n, newBlock, newList;
      n = this.list.indexOf(box);
      if (n === 0) {
        if (this.parentBlock != null) {
          n = this.parentBlock.list.indexOf(this);
          if (n === -1) {
            console.log("**ERROR** in Block.split, could not find", this, "in", this.parentBLock);
          } else {
            newBlock = new Block();
            newBlock.parentBlock = this.parentBlock;
            this.parentBlock.list.splice(n, 1, newBlock);
            this.parentBlock = null;
            Radius.TheBlockList.addBlock(this);
            newBlock.parentBlock.lineUpBlock();
            return;
          }
        } else {
          return;
        }
      }
      if (n === -1) {
        console.log("**ERROR** in Block.split, could not find", box, "in", this);
        return;
      }
      if (box.name === 'else') {
        newList = this.list.splice(n, 3);
      } else {
        newList = this.list.splice(n, 9999);
      }
      newBlock = new Block(newList);
      this.lineUpBlock();
      newBlock.lineUpBlock();
      Radius.TheBlockList.addBlock(newBlock);
    };

    Block.prototype.append = function(box1, box2) {
      var b, blockControlledByElse, insertIntoBlock, insertLoc, insertedBlock, j, k, len, len1, moveToElseList, ref;
      insertedBlock = box2.parentBlock;
      insertLoc = this.list.indexOf(box1);
      if (insertLoc === -1) {
        console.log("***ERROR*** in Block.append, could not find", box1, "in", this);
        return;
      }
      if (box2.name === 'else') {
        if (box1.name === 'if') {
          return this.appendAnElse(box1, box2);
        } else if (box1.controlledByIfWithoutElse()) {
          moveToElseList = this.list.splice(insertLoc + 1, 9999);
          blockControlledByElse = insertedBlock.list[2];
          for (j = 0, len = moveToElseList.length; j < len; j++) {
            b = moveToElseList[j];
            b.parentBlock = blockControlledByElse;
            blockControlledByElse.list.push(b);
          }
          insertIntoBlock = this.parentBlock;
          insertLoc = this.parentBlock.list.indexOf(this);
        }
      } else if (box1.name === 'while' || box1.name === 'if' || box1.name === 'else' || box1.name === 'function') {
        insertIntoBlock = this.list[insertLoc + 2];
        insertLoc = -1;
      } else {
        insertIntoBlock = this;
      }
      ref = insertedBlock.list;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        b = ref[k];
        insertLoc++;
        insertIntoBlock.list.splice(insertLoc, 0, b);
        b.parentBlock = insertIntoBlock;
      }
      Radius.TheBlockList.deleteBlock(insertedBlock);
      return this.lineUpBlock();
    };

    Block.prototype.appendAnElse = function(box1, box2) {
      var b, blockControlledByElse, insertIntoBlock, insertLoc, insertedBlock, j, len, moveToElseList;
      insertedBlock = box2.parentBlock;
      insertLoc = this.list.indexOf(box1);
      if (box1.name === 'if') {
        this.addAfter(insertLoc + 2, [new Block(), box2, insertedBlock.list[1]]);
        this.list[insertLoc + 5].addAfter(0, insertedBlock.list[2]);
        Radius.TheBlockList.deleteBlock(insertedBlock);
        insertedBlock = null;
        return this.lineUpBlock();
      } else if (box1.controlledByIfWithoutElse()) {
        moveToElseList = this.list.splice(insertLoc - 1, 9999);
        blockControlledByElse = insertedBlock.list[2];
        for (j = 0, len = moveToElseList.length; j < len; j++) {
          b = moveToElseList[j];
          b.parentBlock = blockControlledByElse;
          blockControlledByElse.list.push(b);
        }
        insertIntoBlock = this.parentBlock;
        return insertLoc = this.parentBlock.list.indexOf(this);
      }
    };

    Block.prototype.add = function(boxOrBlock) {
      boxOrBlock.parentBlock = this;
      this.list.push(boxOrBlock);
      return this.lineUpBlock();
    };

    Block.prototype.addAfter = function(loc, boxOrBlockList) {
      var b, i, j, len, ref;
      i = 0;
      for (j = 0, len = boxOrBlockList.length; j < len; j++) {
        b = boxOrBlockList[j];
        console.log('changing parent of', b != null ? b.name : void 0, 'from', b != null ? (ref = b.parentBlock) != null ? ref.seq : void 0 : void 0, 'to', this.seq);
        b.parentBlock = this;
        this.list.splice(loc + i, 0, b);
        i++;
      }
      return this.lineUpBlock();
    };

    Block.prototype.deleteBlock = function() {
      this.delete1();
      if (this.list[0].name === "Start") {
        this.list.splice(1, this.list.length);
        $('#' + this.list[0].id).animate({
          left: 20,
          top: 20
        }, 600, (function(_this) {
          return function() {
            _this.list[0].setPos(20, 20);
            return _this.list[0].setSwoopTarget();
          };
        })(this));
        return this.list[0].setPos(20, 20);
      } else {
        return Radius.TheBlockList.deleteBlock(this);
      }
    };

    Block.prototype.delete1 = function() {
      var b, j, len, ref, results;
      ref = this.list;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          if (b.name !== "Start") {
            $;
            $('#' + b.id).remove();
            b.deleted = true;
            if (b === Radius.Box.swoopTargetBox) {
              results.push(Radius.Box.swoopTargetBox = null);
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        } else {
          results.push(b.delete1());
        }
      }
      return results;
    };

    Block.prototype.flagAsDragged = function() {
      var b, j, len, ref;
      ref = this.list;
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          $('#' + b.id).addClass('beingDragged');
        } else {
          b.flagAsDragged();
        }
      }
    };

    Block.prototype.remove = function(box) {
      var n;
      n = this.list.indexOf(box);
      if (n === -1) {
        return console.log("**ERROR** in Block.remove, could not find", box, "in", this);
      } else {
        return this.list.splice(n, 1);
      }
    };

    Block.prototype.addEnd = function() {
      var endBox, theName;
      if (this.list.length > 1) {
        console.log("**ERROR** in Block.addEnd, @list is too long:", this.list.length);
        return;
      }
      this.add(new Radius.Box('bar', 'ProgrammingPane'));
      this.add(new Block());
      theName = this.list[0].name;
      if (theName === 'if' || theName === 'while' || theName === 'function') {
        endBox = new Radius.Box('end' + theName, 'ProgrammingPane');
        return this.add(endBox);
      }
    };

    Block.prototype.getParms = function() {
      var b, j, len, ref, results;
      ref = this.list;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          results.push(b.getParms());
        } else {
          results.push(b.getParms());
        }
      }
      return results;
    };

    Block.prototype.findAttachable = function(movingBox) {
      var attBox, b, boxOrBlock, j, len, ref, x1, y1;
      x1 = movingBox.x;
      y1 = movingBox.y;
      if (movingBox.isAPrototype) {
        x1 += $('#PrototypesPane').offset().left - $('#ProgrammingPane').offset().left;
        y1 += $('#PrototypesPane').offset().top - $('#ProgrammingPane').offset().top;
      }
      ref = this.list;
      for (j = 0, len = ref.length; j < len; j++) {
        boxOrBlock = ref[j];
        if (boxOrBlock.isABox) {
          b = boxOrBlock;
          if (b !== movingBox && !b.deleted && b.name !== 'bar' && y1 <= b.getBottom() + closeEnoughToAttach && y1 >= b.y - closeEnoughToAttach && x1 >= b.x - closeEnoughToAttach && x1 <= b.getRight() + closeEnoughToAttach && movingBox.okToAttach(b)) {
            return b;
          }
        } else {
          attBox = boxOrBlock.findAttachable(movingBox);
          if (attBox != null) {
            return attBox;
          }
        }
      }
      return null;
    };

    Block.prototype.copySelectedBoxes = function() {
      var b, foundSelectedBoxes, j, len, ref;
      if ((this.parentBlock != null) && this.list.length === 0) {
        Radius.copyBuffer.push({
          type: 'block'
        });
        Radius.copyBuffer.push({
          type: 'endblock'
        });
        return;
      }
      foundSelectedBoxes = false;
      ref = this.list;
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          if ($('#' + b.id).hasClass('selected')) {
            if (!foundSelectedBoxes) {
              Radius.copyBuffer.push({
                type: 'block'
              });
              foundSelectedBoxes = true;
            }
            Radius.copyBuffer.push({
              type: 'box',
              boxName: b.name,
              boxParentDivID: b.parentDivID,
              boxParm1: b.parm1,
              boxParm2: b.parm2,
              boxX: b.x,
              boxY: b.y
            });
          }
        } else {
          b.copySelectedBoxes();
        }
      }
      if (foundSelectedBoxes) {
        return Radius.copyBuffer.push({
          type: 'endblock'
        });
      }
    };

    Block.prototype.serialize = function(ser) {
      var b, j, len, ref;
      if ((ser == null) || ser === null) {
        ser = '';
      }
      ser += '[\n';
      ref = this.list;
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          ser += b.name + '//.' + b.parm1 + '//.' + b.parm2 + '//.' + b.x + '//.' + b.y + '\n';
        } else {
          ser = b.serialize(ser);
        }
      }
      ser += ']\n';
      return ser;
    };

    Block.prototype.insertBoxFromArray = function(boxInfo) {
      var newBlocks, newBox;
      newBlocks = [];
      return newBox = new Radius.Box(boxInfo[2], boxInfo[3], boxInfo[4], boxInfo[5]).setPos(boxInfo[6], boxInfo[7]);
    };

    Block.prototype.insertCopyBufferBoxes = function() {
      var b, b1, blockStack, j, len, newBox, ref, results;
      blockStack = [];
      ref = Radius.copyBuffer;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.type === 'block') {
          b1 = new Block();
          if (blockStack.length === 0) {
            Radius.TheBlockList.addBlock(b1);
          } else {
            blockStack[blockStack.length - 1].add(b1);
          }
          results.push(blockStack.push(b1));
        } else if (b.type === 'box') {
          newBox = new Radius.Box(b.boxName, b.boxParentDivID, b.boxParm1, b.boxParm2).setPos(b.boxX + Radius.copyDeltaX, b.boxY + Radius.copyDeltaY);
          $('#' + newBox.id).addClass('lastPasted');
          results.push(blockStack[blockStack.length - 1].add(newBox));
        } else {
          results.push(blockStack.pop());
        }
      }
      return results;
    };

    Block.prototype.insertCopyBufferBoxes1 = function() {
      var b, boxsBlock, j, len, newBlock, newBlocks, newBox, newParentBlock, ref, results;
      newBlocks = [];
      ref = Radius.copyBuffer;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        newBox = new Radius.Box(b.boxName, b.boxParentDivID, b.boxParm1, b.boxParm2).setPos(b.boxX + Radius.copyDeltaX, b.boxY + Radius.copyDeltaY);
        $('#' + newBox.id).addClass('lastPasted');
        console.log('inserting from Copy Buffer', b.boxName);
        boxsBlock = this.findBlockFromCopyBuffer(newBlocks, b.blockSeq);
        if (boxsBlock != null) {
          boxsBlock.add(newBox);
          console.log('...owning block existed');
        } else {
          newBlock = new Block(newBox);
          console.log('...adding owning block, id', b.blockID);
          newBlocks.push({
            oldID: b.blockID,
            block: newBlock
          });
          if (b.parentBlockID == null) {
            console.log('...is top level block');
            Radius.TheBlockList.addBlock(newBlock);
          }
        }
        if (b.parentBlockID != null) {
          console.log('...has a parent, id', b.parentBlockID);
          newParentBlock = this.findBlockFromCopyBuffer(newBlocks, b.parentBlockID);
          if (newParentBlock != null) {
            newBlock.parentBlock = newParentBlock;
            results.push(newParentBlock.add(newBlock));
          } else {
            results.push(console.log('Block.insertCopyBufferBoxes: could not find parent', newBlock));
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Block.prototype.findBlockFromCopyBuffer = function(newBlocks, seq) {
      var j, len, newB;
      for (j = 0, len = newBlocks.length; j < len; j++) {
        newB = newBlocks[j];
        if (newB.oldID === id) {
          return newB.block;
        }
      }
      return null;
    };

    Block.prototype.blockDisplay = function(d) {
      var b, j, len, ref, results;
      if (d == null) {
        d = '>';
        if (this.list.length > 0) {
          console.log('at (', this.list[0].x, this.list[0].y, ') seq:', this.seq);
        }
      }
      if (this.list.length === 0) {
        console.log(d, '--empty block--   seq', this.seq);
        return;
      }
      ref = this.list;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          results.push(console.log(d, b.name, b.parm1, b.parm2, "parent", b.parentBlock.seq));
        } else {
          results.push(b.blockDisplay(d + ' >'));
        }
      }
      return results;
    };

    Block.prototype.findBoxByID = function(boxID) {
      var b, found, j, len, ref;
      ref = this.list;
      for (j = 0, len = ref.length; j < len; j++) {
        b = ref[j];
        if (b.isABox) {
          if (b.id === boxID) {
            return b;
          }
        } else {
          found = b.findBoxByID(boxID);
          if (found != null) {
            return found;
          }
        }
      }
      return null;
    };

    return Block;

  })();

}).call(this);
