// Generated by CoffeeScript 1.10.0

/*
 doParse.coffee
 contains these methods:
 RadiusReset()              // public scope, clears all internal buffers
 RadiusParse(String)        // public scope
 tokenize(String, linenum)  //
 cleanUpTokens
 noteError
 */

(function() {
  var Radius, Token, cleanUpTokens, currID, eatWhiteSpace, noteError, processCommand, processNumber, processString, processSymbol, processWord, rad, startOfParm, subscriptedVar, tokenize, validChar, validCommand, validCommand1, validInNum, validLeftUnaryOperator, validOperator, validReservedWord, validRightUnaryOperator, validStartNum, validSymbol, validSymbol2, validWhite, validWord, whichParm;

  Radius = window.Radius;

  rad = Radius.Code;

  Token = Radius.Token;

  rad.tokens = new Array();

  rad.commandList = new Array();

  rad.errors = new Array();

  rad.removalFuncs = new Array();

  rad.parsingError = false;

  rad.userFunctions = {};

  rad.lastTypeCheckedPos = 0;

  rad.varTypes = {};

  rad.functionNames = [];

  validCommand = /^PRINT$|^CLEAR$|^IF$|^ELSE$|^ENDIF$|^WHILE$|^ENDWHILE$|^BREAK$|^FUNCDO$|^FUNCTION$|^ENDFUNCTION$|^RETURN$|\*LastToken\*/i;

  validCommand1 = /^CLEAR$|^ELSE$|^ENDIF$|^ENDWHILE$|^BREAK$|^ENDFUNCTION$/i;

  validReservedWord = /^true$|^false$|^and$|^or$|^not$|^now$/i;

  validOperator = /^\+$|^\-$|^\*$|^\/$|^&$|^&&$|^and$|^or$|^not$|^\?$|^\[$|^\.$|^\?O$|^\?B$|^<$|^>$|^\=$|^!\=$|^<\=$|^>\=$/i;

  validSymbol = /[\+\-\*\/\[\]\?()&\.<>\=,!:@]/;

  validInNum = /[0123456789.]/;

  validStartNum = /[0123456789]/;

  validChar = /[A-Z]|[a-z]/;

  validWord = /\w/;

  validWhite = /\s/;

  validSymbol2 = /^<\=$|^>\=$|^!\=$|^<\-$|^&&$|^&\/$/;

  validLeftUnaryOperator = /^not$/i;

  validRightUnaryOperator = /^\?$|^\?n$|^\?o$|^\?s$|^\?b$/i;

  subscriptedVar = /^\w+(\.\w+|\[\S*\])+$/;

  Radius.ParseInit = function() {
    rad.errors = [];
    rad.parsingError = false;
    rad.tokens = [];
    rad.commandList = [];
    rad.lastTypeCheckedPos = 0;
    rad.varTypes = {};
    rad.functionNames = ['sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'integer', 'max', 'min', 'abs', 'floor', 'ceiling', 'pow', 'log', 'window', 'plot', 'xrange', 'yrange', 'fillrect', 'clearrect', 'drawrect', 'drawline', 'fillcolor', 'linecolor'];
  };

  Radius.RadiusParse = function(codeText) {
    var errors3, tokensBeforeTokenizing;
    if (typeof codeText !== "string") {
      console.log("Parm to RadiusParse must be a string");
    }
    if (codeText.length === 0) {
      console.log("No source code to parse and compile");
    }
    tokensBeforeTokenizing = rad.tokens.length;
    tokenize(codeText);
    if (rad.errors.length > 0) {
      errors3 = rad.errors.splice(0, 3);
      errors3.push(null);
      return errors3;
    }
    cleanUpTokens(0);
    if (rad.errors.length > 0) {
      errors3 = rad.errors.splice(0, 3);
      errors3.push(null);
      return errors3;
    }
    return [];
  };

  currID = "<noID>";

  startOfParm = 0;

  whichParm = 1;

  tokenize = function(s) {
    var i, s1, starting_i;
    i = 0;
    s1 = s + " ";
    while (i < s1.length - 1) {
      starting_i = i;
      i = eatWhiteSpace(s1, i);
      i = processNumber(s1, i);
      i = processString(s1, i);
      i = processSymbol(s1, i);
      i = processCommand(s1, i);
      i = processWord(s1, i);
      if (i === starting_i) {
        console.log("tokenize: no parsing match at", s1.substring(i));
        break;
      }
    }
  };

  eatWhiteSpace = function(s, i) {
    while (s.substring(i, i + 1).match(validWhite)) {
      i++;
    }
    return i;
  };

  processNumber = function(s, i) {
    var num, start;
    if (!s.substring(i, i + 1).match(validStartNum)) {
      return i;
    }
    start = i;
    i++;
    while (s.substring(i, i + 1).match(validInNum)) {
      i++;
    }
    if (s.substring(i, i + 1).match(validChar)) {
      noteError(currID, whichParm, i - startOfParm, 1, "The character " + s.substring(i, i + 1) + " cannot be in a number. (P11)");
    }
    num = new Token(Token.Number, s.substring(start, i), currID, whichParm, start - startOfParm, i - start);
    if (num.error) {
      noteError(currID, whichParm, start - startOfParm, i - start, "Not a valid number. (P12)");
    } else {
      rad.tokens.push(num);
    }
    return i;
  };

  processString = function(s, i) {
    var openQuote, start;
    openQuote = s.substring(i, i + 1);
    if (openQuote === "'" || openQuote === '"') {
      start = i;
      i++;
      while (!(s.substring(i, i + 1) === openQuote || i >= s.length)) {
        i++;
      }
      if (i >= s.length) {
        noteError(currID, whichParm, start - startOfParm, i - start, "Closing quotation mark is missing. (P15)");
      } else {
        rad.tokens.push(new Token(Token.String, s.substring(start + 1, i), currID, whichParm, start - startOfParm, (i + 1) - start));
      }
      return i + 1;
    }
    return i;
  };

  processSymbol = function(s, i) {
    if (s.substring(i, i + 1).match(validSymbol)) {
      if (s.substring(i, i + 2).match(validSymbol2)) {
        rad.tokens.push(new Token(Token.Symbol, s.substring(i, i + 2), currID, whichParm, i - startOfParm, 2));
        return i + 2;
      } else {
        rad.tokens.push(new Token(Token.Symbol, s.substring(i, i + 1), currID, whichParm, i - startOfParm, 1));
        return i + 1;
      }
    } else {
      return i;
    }
  };

  processCommand = function(s, i) {
    var start, thatCommand;
    if (s.substring(i, i + 1) === '#') {
      start = i;
      while (!s.substring(i, i + 1).match(validWhite)) {
        i++;
      }
      if (s.substring(start, start + 2) === '##') {
        currID = s.substring(start + 2, i);
      } else {
        rad.tokens.push(new Token(Token.Command, s.substring(start, i), currID, 0, 0, 1));
        startOfParm = i + 1;
        thatCommand = rad.tokens[rad.tokens.length - 1].val;
        if (thatCommand === '#GETS') {
          whichParm = 2;
        } else {
          whichParm = 1;
        }
      }
    }
    return i;
  };

  processWord = function(s, i) {
    var start;
    if (s.substring(i, i + 1).match(validChar)) {
      start = i;
      while (s.substring(i, i + 1).match(validWord)) {
        i++;
      }
      rad.tokens.push(new Token(Token.Word, s.substring(start, i), currID, whichParm, start - startOfParm, i - start));
    }
    return i;
  };

  cleanUpTokens = function(startingAt) {
    var i, j, k, length, match, mydepth, myserial, mystack, notmatch, ref, ref1, ref2, ref3, results, sawASSIGN, tok;
    length = rad.tokens.length;
    mystack = [];
    myserial = 1;
    mydepth = 0;
    sawASSIGN = false;
    if (length <= startingAt) {
      console.log("Problem in cleanUpTokens, no tokens to clean up.");
      console.log("startingAt:", startingAt, "rad.tokens:", rad.tokens);
      return;
    }
    for (i = j = ref = startingAt, ref1 = length - 1; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      tok = rad.tokens[i];
      if (tok.type === Token.Command && tok.val === "#FUNCTION" && rad.tokens[i + 1].type === Token.Word) {
        rad.functionNames.push(rad.tokens[i + 1].val);
      }
    }
    for (i = k = ref2 = startingAt, ref3 = length; ref2 <= ref3 ? k < ref3 : k > ref3; i = ref2 <= ref3 ? ++k : --k) {
      tok = rad.tokens[i];
      if ((tok.type === Token.Word || tok.type === Token.Symbol) && tok.val.match(validOperator)) {
        tok.type = Token.Operator;
      } else if (tok.type === Token.Word && rad.functionNames.indexOf(tok.val) > -1) {
        tok.ty = Token.Function;
      }
      if (tok.type === Token.Command) {
        if (mystack.length !== 0) {
          notmatch = mystack.pop();
          noteError(rad.tokens[notmatch.index].id, rad.tokens[notmatch.index].whichParm, rad.tokens[notmatch.index].start, 1, rad.tokens[notmatch.index].val + " is not closed. (P22)");
        }
        mydepth === 0;
      } else if (tok.sym === "(") {
        mystack.push({
          index: i,
          sym: "("
        });
        tok.depth = mydepth;
        mydepth++;
      } else if (tok.sym === "[") {
        mystack.push({
          index: i,
          sym: "["
        });
        tok.depth = mydepth;
        mydepth++;
      } else if (tok.sym === ")" || tok.sym === "]") {
        if (mystack.length === 0) {
          noteError(tok.id, tok.whichParm, tok.start, tok.start + 1, tok.val + " does not have an opening partner.  (P23)");
        } else {
          match = mystack.pop();
          if ((match.sym === "[" && tok.sym === "]") || (match.sym === "(" && tok.sym === ")")) {
            rad.tokens[match.index].serial = myserial;
            tok.serial = myserial;
            myserial++;
            mydepth--;
            tok.depth = mydepth;
          } else {
            noteError(rad.tokens[match.index].id, rad.tokens[match.index].whichParm, rad.tokens[match.index].start, rad.tokens[i].start - rad.tokens[match.index].start + 1, rad.tokens[match.index].val + " does not match with" + rad.tokens[i].val + ". (P24)");
            mystack.push(match);
          }
        }
      } else {
        tok.depth = mydepth;
      }
      if (tok.type === Token.Command && tok.val === "#ASSIGN") {
        sawASSIGN = true;
      }
      if (tok.type === Token.Word) {
        if ((rad.tokens[i + 1] != null) && rad.tokens[i + 1].val === ":") {
          tok.type = Token.Label;
        } else if (i > 0 && rad.tokens[i - 1].val === ".") {
          tok.type = Token.Label;
        } else if (sawASSIGN) {
          tok.type = Token.LVal;
          sawASSIGN = false;
        } else {
          tok.type = Token.RVal;
        }
      }
    }
    results = [];
    while (mystack.length !== 0) {
      notmatch = mystack.pop();
      results.push(noteError(rad.tokens[notmatch.index].id, rad.tokens[notmatch.index].whichParm, rad.tokens[notmatch.index].start, 1, rad.tokens[notmatch.index].val + " is not closed. (P25)"));
    }
    return results;
  };

  noteError = function(id, whichParm, startPos, length, message) {
    if (typeof startPos === "number" && typeof length === "number") {
      rad.errors.push(["" + id, whichParm, startPos, length, message]);
    } else {
      console.log("doParse noteError: bad parms: ", id, whichParm, startPos, length, message);
    }
    return rad.parsingError = true;
  };

}).call(this);
